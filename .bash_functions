#############################################
# ~/.bash_functions - Funciones personalizadas nivel PRO
# Modular complementario a ~/.bashrc y ~/.bash_aliases
# Incluye utilidades, Git, FZF, GitHub, K8s/OC y ayuda interactiva
#############################################

########## üìÅ UTILIDADES GENERALES ##########

# mkcd <directorio>: crea una carpeta y entra en ella
mkcd() {
  mkdir -p "$1" && cd "$1"
}

# extract <archivo>: extrae archivos comprimidos seg√∫n extensi√≥n
extract() {
  if [ -f "$1" ]; then
    case "$1" in
      *.tar.bz2) tar xjf "$1" ;;
      *.tar.gz)  tar xzf "$1" ;;
      *.bz2)     bunzip2 "$1" ;;
      *.rar)     unrar x "$1" ;;
      *.gz)      gunzip "$1" ;;
      *.tar)     tar xf "$1" ;;
      *.tbz2)    tar xjf "$1" ;;
      *.tgz)     tar xzf "$1" ;;
      *.zip)     unzip "$1" ;;
      *.Z)       uncompress "$1" ;;
      *.7z)      7z x "$1" ;;
      *)         echo "‚ùå '$1' no puede extraerse autom√°ticamente" ;;
    esac
  else
    echo "‚ùå '$1' no es un archivo v√°lido"
  fi
}

# extract_all: extrae todos los archivos comprimidos del directorio actual
extract_all() {
  for file in *; do
    extract "$file"
  done
}

# timer <comando>: mide el tiempo de ejecuci√≥n de un comando
timer() {
  start=$(date +%s)
  "$@"
  end=$(date +%s)
  echo "‚è± Tiempo total: $((end - start)) segundos"
}

# ipinfo_local: muestra IP local y p√∫blica
ipinfo_local() {
  echo "üì° IP local:"
  ip -4 addr show | grep inet
  echo "üåç IP p√∫blica:"
  curl -s https://icanhazip.com
}

# cleanup: elimina archivos temporales y backups
cleanup() {
  echo "üßπ Limpiando archivos temporales y backups..."
  find . -type f \( -name '*~' -o -name '*.bak' -o -name '*.tmp' \) -delete
}

# ffind <texto>: b√∫squeda recursiva por nombre (ignora may√∫sculas)
ffind() {
  find . -iname "*$1*"
}

########## üåø FUNCIONES GIT / GITHUB ##########

# gitinfo: muestra informaci√≥n √∫til del repositorio actual
gitinfo() {
  if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    echo "‚ö† No est√°s dentro de un repositorio Git."
    return 1
  fi
  echo -e "\nüìÇ Ruta del repositorio: \033[1;34m$(git rev-parse --show-toplevel)\033[0m"
  local branch=$(git symbolic-ref --short HEAD 2>/dev/null)
  echo -e "üåø Rama actual: \033[1;33m$branch\033[0m"
  echo -e "üîç √öltimo commit:"
  git log -1 --pretty=format:"  üìå Hash: %h%n  üìù Mensaje: %s%n  üë§ Autor: %an%n  üïì Fecha: %ad" --date=short
  echo -e "\nüìÑ Estado del repositorio:"
  if [[ -n $(git status --porcelain) ]]; then
    echo "  ‚ö† Hay cambios sin confirmar:"
    git status --short
  else
    echo "  ‚úÖ El repositorio est√° limpio"
  fi
  echo
}

# gitupdate: flujo completo de add + commit + push con interacci√≥n
gitupdate() {
  if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    echo "‚ùå No est√°s en un repositorio Git."
    return 1
  fi

  echo -e "\nüìÇ Estado actual del repo:"
  git status -sb

  local changes_staged=$(git diff --cached --name-only)
  local changes_unstaged=$(git diff --name-only)
  local untracked=$(git ls-files --others --exclude-standard)

  if [[ -z "$changes_staged" && -z "$changes_unstaged" && -z "$untracked" ]]; then
    echo "‚úÖ Todo limpio. No hay cambios que subir."
    return 0
  fi

  echo -e "\nüîç Cambios detectados:"
  [[ -n "$changes_staged" ]] && echo "‚úÖ Cambios listos para commit."
  [[ -n "$changes_unstaged" ]] && echo "üìù Cambios sin a√±adir al staging."
  [[ -n "$untracked" ]] && echo "üÜï Archivos nuevos no seguidos."

  read -p "¬øA√±adir TODOS los cambios al commit? (s/N): " addresp
  [[ "$addresp" =~ ^[sS]$ ]] && git add -A || { echo "‚ùå No se han a√±adido archivos."; return 0; }

  read -p "üóíÔ∏è  Escribe mensaje de commit: " msg
  [[ -z "$msg" ]] && echo "‚ùå Mensaje vac√≠o. Abortando." && return 1
  git commit -m "$msg"

  read -p "‚¨Ü ¬øPush al remoto? (s/N): " pushresp
  [[ "$pushresp" =~ ^[sS]$ ]] && git push && echo "üöÄ Push hecho." || echo "‚úÖ Commit local realizado."
}

# git_prompt_status_auto: muestra status autom√°ticamente al entrar en un repo nuevo
__last_git_repo_root=""
git_prompt_status_auto() {
  if git rev-parse --is-inside-work-tree &>/dev/null; then
    current_git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    if [[ "$current_git_root" != "$__last_git_repo_root" ]]; then
      __last_git_repo_root="$current_git_root"
      echo -e "\nüìÇ Git status en $(basename "$current_git_root"):\n"
      git status -sb
      UPSTREAM=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)
      if [ $? -eq 0 ]; then
        AHEAD=$(git rev-list "$UPSTREAM"..HEAD --count)
        BEHIND=$(git rev-list HEAD.."$UPSTREAM" --count)
        [[ "$AHEAD" -gt 0 && "$BEHIND" -gt 0 ]] && echo "üîÅ Adelantado $AHEAD y atrasado $BEHIND commits respecto a '$UPSTREAM'"
        [[ "$AHEAD" -gt 0 ]] && echo "‚¨Ü $AHEAD commit(s) por subir"
        [[ "$BEHIND" -gt 0 ]] && echo "‚¨á $BEHIND commit(s) nuevos en remoto"
        [[ "$AHEAD" -eq 0 && "$BEHIND" -eq 0 ]] && echo "‚úÖ Repo sincronizado con '$UPSTREAM'"
      else
        echo "‚ö† No hay upstream configurado para esta rama."
      fi
    fi
  else
    __last_git_repo_root=""
  fi
}

# === ghconn: reconecta GitHub restaurando credenciales
ghconn() {
  if [ -f ~/.git-credentials.disabled ]; then
    mv ~/.git-credentials.disabled ~/.git-credentials
    echo "üîê Credenciales GitHub restauradas."
  else
    echo "‚úÖ Las credenciales ya estaban activas."
  fi

  echo "üîç Verificando conexi√≥n con GitHub..."
  local token_url=$(grep 'github.com' ~/.git-credentials | sed 's/https:\/\///g')
  if curl -s -o /dev/null -w "%{http_code}" "https://${token_url}" | grep -q "200\|301"; then
    echo "üêô GitHub ${token_url%%:*} conectado correctamente."
  else
    echo "‚ùå GitHub ${token_url%%:*} - token inv√°lido o sin acceso."
  fi
}

# === ghtokenupdate: cambia el token de acceso GitHub
ghtokenupdate() {
  echo "üîë Actualizando token de GitHub..."
  read -p "üë§ GitHub username: " ghuser
  read -s -p "üîë Nuevo GitHub Token (PAT): " newtoken
  echo
  echo "‚úÖ Guardando token en ~/.git-credentials"
  echo "https://${ghuser}:${newtoken}@github.com" > ~/.git-credentials
  git config --global credential.helper store
  echo "üîÑ Probando conexi√≥n con GitHub..."
  if git ls-remote https://github.com &>/dev/null; then
    echo "üêô Nuevo token GitHub v√°lido. ¬°Listo!"
  else
    echo "‚ùå El nuevo token parece inv√°lido o hay error de red."
  fi
}

########## üîç FUNCIONES CON FZF ##########

catf() {
  local file
  file=$(ls | fzf --prompt="üìÇ Elige archivo para ver: ")
  [[ -n "$file" ]] && cat "$file"
}

catfp() {
  local file
  file=$(ls | fzf --preview 'head -n 20 {}' --prompt="üìÇ Archivo con preview: ")
  [[ -n "$file" ]] && cat "$file"
}

cdf() {
  local dir
  dir=$(find . -type d 2>/dev/null | fzf --prompt="üìÅ Carpeta destino: ")
  [[ -n "$dir" ]] && cd "$dir"
}

vimf() {
  local file
  file=$(ls | fzf --prompt="üìù Editar archivo: ")
  [[ -n "$file" ]] && vim "$file"
}

########## DASHBOARD #############
dashboard() {
  clear
  C1='\033[1;95m'; C2='\033[1;96m'; CK='\033[1;92m'; CV='\033[0;37m'; CI='\033[1;90m'; R='\033[0m'

  # Imprime clave y valor con padding visible correcto
  P() {
    local key="$1:"; local val="$2"
    local pad=18
    local clean_len=${#key}
    local spacing=$(printf '%*s' $((pad - clean_len)) "")
    printf "  ${CK}%s${spacing}${CV}%s${R}\n" "$key" "$val"
  }

  S() { echo -e "\n${C2}‚ñ∂ $1${R}"; }

  HOST=$(hostname)
  USER=$(whoami)
  SO=$(lsb_release -ds 2>/dev/null | tr -d '"')
  KERNEL=$(uname -r)
  CPU=$(lscpu | awk -F: '/Model name/ {print $2}' | sed 's/^ *//')
  UPTIME=$(uptime -p | sed 's/^up //')
  MEM=$(free -h | awk '/Mem:/ {printf "%.1f%s libres de %.1f%s", $4, substr($4,length($4)), $2, substr($2,length($2))}')
  DISK=$(df -h / | awk 'NR==2 {printf "%.1f%s usados de %.1f%s (%s)", $3, substr($3,length($3)), $2, substr($2,length($2)), $5}')
  IFACE=$(ip route get 1.1.1.1 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="dev") print $(i+1)}')
  IP_LOCAL=$(ip -4 -o addr show "$IFACE" | awk '{print $4}' | cut -d/ -f1)
  IP_PUB=$(curl -s https://api.ipify.org)

  echo -e "${C1}====== DASHBOARD DEL SISTEMA ======${R}"
  S "Informaci√≥n General"; P "Hostname" "$HOST"; P "Usuario" "$USER"; P "SO/Kernel" "$SO ($KERNEL)"
  P "CPU" "$CPU"; P "Tiempo Activo" "$UPTIME"
  S "Recursos"; P "Memoria Libre" "$MEM"; P "Disco Usado (/)" "$DISK"
  S "Red"; P "IP Local" "$IP_LOCAL"; P "IP P√∫blica" "$IP_PUB"
  echo -e "\n${CI}[$USER@$HOST]${R}\n"
}








########## üìö AYUDA GLOBAL ##########
# === ayuda: muestra ayuda extendida de funciones + alias personalizados ===
ayuda_completa() {
  echo -e "\n\033[1;36m=========== üìö AYUDA COMPLETA - FUNCIONES & ALIAS ===========\033[0m"

  echo -e "\n\033[1;33müß† FUNCIONES PERSONALIZADAS:\033[0m"

  echo -e "\nüîß Utilidades generales:"
  echo "  mkcd <dir>         ‚Üí Crea una carpeta y entra en ella (ej: mkcd nueva_carpeta)"
  echo "  extract <archivo>  ‚Üí Extrae un archivo comprimido (ej: extract archivo.zip)"
  echo "  extract_all        ‚Üí Extrae todos los archivos comprimidos del directorio actual"
  echo "  cleanup            ‚Üí Elimina temporales (*.tmp *.bak *~)"
  echo "  ipinfo_local       ‚Üí Muestra IP local y p√∫blica"
  echo "  ffind <texto>      ‚Üí Busca archivos por nombre (ej: ffind nginx)"
  echo "  timer <cmd>        ‚Üí Mide tiempo ejecuci√≥n (ej: timer sleep 3)"

  echo -e "\nüîç Funciones con fzf:"
  echo "  catf               ‚Üí Elige archivo y muestra con cat"
  echo "  catfp              ‚Üí Como catf pero con preview (head -n 20)"
  echo "  vimf               ‚Üí Edita archivo elegido con fzf (usa vim)"
  echo "  cdf                ‚Üí Cambia a carpeta elegida con fzf"

  echo -e "\nüåø Git & GitHub:"
  echo "  gitinfo            ‚Üí Info del repo actual (rama, √∫ltimo commit, cambios...)"
  echo "  gitupdate          ‚Üí Commit interactivo (status, mensaje, push)"
  echo "  git_prompt_status_auto ‚Üí Muestra estado git al cambiar de repo"
  echo "  ghconn             ‚Üí Activa credenciales GitHub (restaura .git-credentials)"
  echo "  ghdisconn          ‚Üí Desactiva temporalmente credenciales GitHub"

  echo -e "\nüñ•Ô∏è Info del sistema:"
  echo "  dashboard          ‚Üí Panel t√©cnico general + Git info"

  echo -e "\n\033[1;33müß© ALIAS DISPONIBLES:\033[0m"

  echo -e "\nüìÅ Navegaci√≥n r√°pida:"
  echo "  .., ..., ....      ‚Üí Subir niveles"
  echo "  gohome             ‚Üí Ir a Documentos"

  echo -e "\nüìÇ Listados mejorados (usa eza):"
  echo "  ls, ll, la, lt     ‚Üí Listados coloridos, √°rbol, git, ocultos..."

  echo -e "\nüßπ Limpieza y terminal:"
  echo "  cls                ‚Üí Limpiar pantalla"
  echo "  reload             ‚Üí Recargar configuraci√≥n bash (source ~/.bashrc)"

  echo -e "\nüìä Informaci√≥n sistema:"
  echo "  cpu, mem, disk     ‚Üí CPU, RAM, espacio disco"
  echo "  ipinfo, ports      ‚Üí IPs y puertos en uso"
  echo "  neoinfo            ‚Üí Mostrar info completa con neofetch"

  echo -e "\nüì¶ Paquetes (apt):"
  echo "  update, up         ‚Üí Actualizar sistema"
  echo "  install, remove    ‚Üí Instalar / eliminar paquetes"
  echo "  purge, autoremove  ‚Üí Limpieza completa"
  echo "  clean              ‚Üí Vaciar cach√© apt"

  echo -e "\nüîç Procesos y red:"
  echo "  psg <texto>        ‚Üí Buscar procesos"
  echo "  topc               ‚Üí Lanzar htop"
  echo "  pingg              ‚Üí Ping a 8.8.8.8"
  echo "  netcheck           ‚Üí IP p√∫blica r√°pida"
  echo "  speed              ‚Üí Test de velocidad terminal"

  echo -e "\nüåø Git r√°pido:"
  echo "  gs, ga, gc, gp     ‚Üí status, add, commit, push"
  echo "  gl, gco, gb, gd    ‚Üí log, checkout, branch, diff"

  echo -e "\nüß∞ Utilidades varias:"
  echo "  mkdir              ‚Üí mkdir -pv (con -p y verbose)"
  echo "  h, hgrep           ‚Üí Historial / filtrar historial"
  echo "  f <texto>          ‚Üí find por nombre"
  echo "  v                  ‚Üí Abrir con nano"
  echo "  bat                ‚Üí Usar batcat para ver archivos"
  echo "  getgh              ‚Üí Ir a carpeta github local"

  echo -e "\n‚ò∏Ô∏è OpenShift / Kubernetes:"
  echo "  oclogin            ‚Üí Login r√°pido a cl√∫ster OC"
  echo "  ocp, ocs, ocns     ‚Üí Pods, servicios, proyecto OC"
  echo "  occtx, ocwho       ‚Üí Contexto y usuario OC"
  echo "  k, kgp, kgs, kctx, kns ‚Üí Alias para kubectl"
  echo "  opentoken <fqdn>   ‚Üí Abre token OC (ej: opentoken cluster...opentlc.com)"
  echo "  clusterstatus      ‚Üí Estado del cl√∫ster K8s/OC"
  echo "  clusterlogout      ‚Üí Salir del cl√∫ster actual"

  echo -e "\nüÜò Esta ayuda tambi√©n se puede mostrar con:\n  ayuda, help o ayudame"

  echo -e "\n\033[1;36m============================================================\033[0m"
}
alias ayudame='ayuda'

# === ayuda <palabra>: busca coincidencias en la ayuda completa ===
ayuda() {
  local filtro="$1"
  local actual=""
  local imprimir_seccion=false

  highlight() {
  if [[ -n "$filtro" ]]; then
    echo "$1" | grep --color=always -i "$filtro" || echo "$1"
  else
    echo "$1"
  fi
  }


  while IFS= read -r linea; do
    if [[ "$linea" =~ ^(üîß|üìÅ|üåø|üßπ|üì¶|‚ò∏Ô∏è|üìÇ|üß∞|üìä|üß†|üñ•Ô∏è|üÜò|üîç|üìö|üß©|üìÑ|üìù|üóíÔ∏è|üêô|üöÄ) ]]; then
      actual="$linea"
      imprimir_seccion=false
    elif [[ -z "$filtro" ]]; then
      [[ -n "$actual" ]] && echo -e "\n\033[1;33m$actual\033[0m" && actual=""
      echo "$(highlight "$linea")"
    elif echo "$linea" | grep -i -q "$filtro"; then
      if [[ "$imprimir_seccion" = false ]]; then
        echo -e "\n\033[1;33m$actual\033[0m"
        imprimir_seccion=true
      fi
      echo "$(highlight "$linea")"
    fi
  done < <(ayuda_completa)
}




